
from __future__ import annotations

from homeassistant.core import HomeAssistant, ServiceCall
from homeassistant.config_entries import ConfigEntry
from homeassistant.helpers import entity_registry as er, area_registry as ar, device_registry as dr
from homeassistant.helpers import label_registry as lr  # HA >= 2024.4
from homeassistant.const import Platform

from .const import DOMAIN, CONF_LABEL, CONF_MAP_AREAS, DEFAULT_LABEL, OUTFILE, PLATFORMS

import os

async def async_setup(hass: HomeAssistant, config: dict):
    return True

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry):
    # store options
    hass.data.setdefault(DOMAIN, {})
    hass.data[DOMAIN][entry.entry_id] = entry

    # register services
    async def handle_rebuild(call: ServiceCall):
        label = entry.options.get(CONF_LABEL, entry.data.get(CONF_LABEL, DEFAULT_LABEL))
        map_areas = entry.options.get(CONF_MAP_AREAS, entry.data.get(CONF_MAP_AREAS, True))
        await _rebuild(hass, label, map_areas)
        await hass.services.async_call(
            "persistent_notification",
            "create",
            {
                "title": "GA Labels",
                "message": "Konfiguration erzeugt → Home Assistant neu starten und danach in Google Assistant 'request_sync' ausführen (Button vorhanden).",
                "notification_id": "ga_labels_rebuild",
            },
        )

    hass.services.async_register(DOMAIN, "rebuild", handle_rebuild)

    await hass.config_entries.async_forward_entry_setups(entry, [Platform.BUTTON, Platform.SWITCH])
    return True

async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry):
    unload_ok = await hass.config_entries.async_unload_platforms(entry, [Platform.BUTTON, Platform.SWITCH])
    if unload_ok:
        hass.data[DOMAIN].pop(entry.entry_id, None)
    return unload_ok

async def _rebuild(hass: HomeAssistant, label_name: str, map_areas: bool):
    ent_reg = er.async_get(hass)
    dev_reg = dr.async_get(hass)
    lab_reg = lr.async_get(hass)
    area_reg = ar.async_get(hass)

    # find label id
    target_label = next((l for l in lab_reg.labels.values() if l.name == label_name), None)

    lines = ["# generated by ga_labels"]
    lines.append("entity_config:")

    if not target_label:
        lines.append(f"  # Label nicht gefunden: {label_name}")
        content = "\n".join(lines) + "\n"
        await _write(hass, content)
        return

    # sort by entity_id for stable output
    for entity in sorted(ent_reg.entities.values(), key=lambda e: e.entity_id):
        if not entity.entity_id:
            continue
        if target_label.id not in (entity.labels or []):
            continue

        lines.append(f"  {entity.entity_id}:")
        lines.append("    expose: true")

        if map_areas:
            area = None
            if entity.area_id:
                area = area_reg.areas.get(entity.area_id)
            else:
                dev = dev_reg.devices.get(entity.device_id) if entity.device_id else None
                if dev and dev.area_id:
                    area = area_reg.areas.get(dev.area_id)
            if area:
                # Room names should be plain strings; Google handles Unicode
                room_name = area.name
                lines.append(f"    room: {room_name}")

    lines.append("")
    content = "\n".join(lines)

    await _write(hass, content)

async def _write(hass: HomeAssistant, content: str):
    out_path = hass.config.path(OUTFILE)

    def _do_write():
        # backup if exists
        if os.path.exists(out_path):
            try:
                os.replace(out_path, out_path + ".bak")
            except Exception:
                pass
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(content if content.endswith("\n") else content + "\n")

    await hass.async_add_executor_job(_do_write)
